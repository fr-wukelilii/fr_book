```
添加多个
```



# 7.springCloud

## 1.微服务架构

```
问题：
	什么是微服务架构。

1.架构演变：
	springCloud是微服务架构的具体实现。
	集中式架构：维护困难，开发快，一个服务挂了整个就挂了。
	垂直架构：业务功能独立，代码重复率高，多次调用功能。
	分布式架构：逻辑功能独立，互相调用
	ESB面向服务架构：业务功能独立，多个系统访问注册中心，来找其他多个系统。都通过注册中心来调用，通路通信速度慢
	微服务架构：逻辑功能独立，用户通过网关，多个系统把地址给
	
2.微服务架构：
	请求经过网关（网关通过路由去分配访问地址，记录日志），每个功能在服务治理中心管理ip地址，传给网关。它是rest风格。（路径加{}，注解用PathVariable）
	单一职责，服务粒度小，面向服务，服务间独立。
	与ESB区别：有服务治理注册中心。
	
3.服务调用方式：
	RPC协议：基于socket，速度快，webservice，dubbo都是。
	http协议:技术和语言没限定，PHP语言也能传数据，缺点传数据封装比较臃肿。springCloud是。
	
4.springCloud提供的springRestTemplate：
	操作http的工具类heepClient...，封装了各种工具类。
	操作方式：
		现在启动类中写获取该对象的bean方法
		用对象的getForObject(url,User.class)方法，去访问url所指向的地址（controller操作数据库返回的实体类），获取的结果封装到User.class中。
	可以将json数据(字符串)反序列化成对象
	
5.springCloud概念：
	它微服务架构的一个框架，是基于springBoot开发，整合很多技术（各种组件），有spring做靠山。是很多组件的组合。
	组件组成：Eureka注册中心，网关，负载均衡Ribbon，服务调用，熔断器Hystrix。怎么去配合？
	
6.springCloud工程搭建：
	父工程注意：
		父工程包为pom，
		指定父spring-boot起步依赖
		依赖版本锁定中添加spring-cloud,指定其类型为pom（让子工程有第二父项目），加scope属性为import（把第二个父项目导入进来）
	子工程：
    	导入web起步依赖 （这不是在父工程中导入）

7.一个消费方跟一个服务方远程调用存在问题：
	消费方不清楚服务方是否开启。
	如果服务方集群，消费方访问还要自己实现负载均衡来考虑用哪个服务。
	容灾问题，如果一个服务器挂了，该怎么办。
    注意：这些问题都可以通过组件来解决。
    
8.各种组件：
	1.Eureka注册中心：
		背景：
			服务方出现了地址变更，消费方还要更新地址，这种人为更新在服务大面积改地址的时候，人为管理很麻烦。
			Eureka与服务方通过心跳机制进行监控，服务方出问题，Eureka就知道并剔除。实现了服务的自动注册，发现和监控。
         操作：
         	启动类上多加个注解，表示该工程为Eureka注册中心。
            配置文件yml中配ip+端口号+域名，还要配不注册自己（如果有注册中心集群，就要注册），不拉去服务。
         服务方注册到注册中心：
         	引入依赖，启动类上加服务注解。
         	配置文件yml中，application配自己在注册中心的名字，eureks中配要连接的注册中心url：10086端口号
         总体思路：
        	消费方获取服务方url不是固定的，是加载配置文件中配的Eureka，从它里面来获取服务方，url是动态拼接的。
       
    2.负载均衡Ribbon：
    	springCloud内置的第三方组件，默认两种算法/策略：轮训（顺序循环找），随机。用于注册中心有多个服务器的时候。
    	
    4.熔断器Hystrix：
    	1.概念：
            是一个库，防止出现级联失败。
            雪崩：可能一个请求访问多个微服务，如果一个微服务挂掉，那么其他请求也不会执行，tomcat不会释放这个线程，这时候就会造成阻塞。
            Hystrix解决雪崩通过服务降级： 线程隔离和服务熔断。
    	2.线程隔离：
        	请求不是直接到服务，而是到线程池，它会分配一定的空闲的线程去访问服务，如果服务故障，线程池满，就会立即拒绝这次服务，如果线程访问某个服务超时，就立即返回提示信息，这就是服务降级。
        4.服务熔断和服务降级：
        	服务降级就是请求一个服务超时，就返回一个信息，当做是已经调用了这个服务，这样做可以避免线程阻塞。
        	服务熔断就是通过断路器，它默认是关闭，如果访问出现20次有超过一般的失败信息，断路器就会打开，将所有请求进行降级处理，不过过了五秒断路器还会变成半开状态，部分请求依旧进行，如果一旦成功的化依旧打开。
        	
```

